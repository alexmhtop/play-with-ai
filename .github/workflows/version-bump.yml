name: Version Bump

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  determine-bump:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      bump_type: ${{ steps.analyze.outputs.bump_type }}
      current_version: ${{ steps.version.outputs.current }}
      new_version: ${{ steps.calc.outputs.new }}
      previous_tag: ${{ steps.version.outputs.previous_tag }}
      should_bump: ${{ steps.analyze.outputs.should_bump }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current version
        id: version
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            CURRENT_VERSION="0.0.0"
          else
            CURRENT_VERSION="${LATEST_TAG#v}"
          fi
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "previous_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION (prev tag: $LATEST_TAG)"

      - name: Analyze commits for version bump
        id: analyze
        run: |
          BUMP_TYPE="${{ inputs.bump_type || 'auto' }}"

          if [ "$BUMP_TYPE" = "auto" ]; then
            # Get commits since last tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

            if [ -z "$LATEST_TAG" ]; then
              COMMITS=$(git log --oneline)
            else
              COMMITS=$(git log "${LATEST_TAG}..HEAD" --oneline)
            fi

            if [ -z "$COMMITS" ]; then
              echo "No new commits since last tag"
              echo "should_bump=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Analyze commit messages for conventional commits
            HAS_BREAKING=$(echo "$COMMITS" | grep -iE '(BREAKING CHANGE|!:)' || true)
            HAS_FEAT=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ feat' || true)
            HAS_FIX=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ fix' || true)

            if [ -n "$HAS_BREAKING" ]; then
              BUMP_TYPE="major"
            elif [ -n "$HAS_FEAT" ]; then
              BUMP_TYPE="minor"
            elif [ -n "$HAS_FIX" ]; then
              BUMP_TYPE="patch"
            else
              echo "No version-affecting commits found"
              echo "should_bump=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "should_bump=true" >> $GITHUB_OUTPUT
          echo "Determined bump type: $BUMP_TYPE"

      - name: Calculate new version
        id: calc
        if: steps.analyze.outputs.should_bump == 'true'
        run: |
          CURRENT="${{ steps.version.outputs.current }}"
          BUMP_TYPE="${{ steps.analyze.outputs.bump_type }}"

          MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          MINOR=$(echo "$CURRENT" | cut -d. -f2)
          PATCH=$(echo "$CURRENT" | cut -d. -f3 | cut -d- -f1)

          # Handle missing parts
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          case "$BUMP_TYPE" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

  create-bump-pr:
    needs: determine-bump
    if: needs.determine-bump.outputs.should_bump == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update version files
        id: update
        run: |
          NEW_VERSION="${{ needs.determine-bump.outputs.new_version }}"
          if [ -z "$NEW_VERSION" ]; then
            echo "New version was not calculated; ensure tags exist or calculation step ran" >&2
            exit 1
          fi

          UPDATED=false

          # Update pyproject.toml if it exists and has version
          if [ -f "pyproject.toml" ] && grep -q '^version = ' pyproject.toml; then
            sed -i "s/^version = .*/version = \"$NEW_VERSION\"/" pyproject.toml
            UPDATED=true
          fi

          # Update __version__ in src/__init__.py if it exists
          if [ -f "src/__init__.py" ] && grep -q '__version__' src/__init__.py; then
            sed -i "s/__version__ = .*/__version__ = \"$NEW_VERSION\"/" src/__init__.py
            UPDATED=true
          fi

          # Update VERSION file if it exists
          if [ -f "VERSION" ]; then
            echo "$NEW_VERSION" > VERSION
            UPDATED=true
          fi

          # Update package.json if it exists (for mixed projects)
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" package.json
            UPDATED=true
          fi

          echo "updated=$UPDATED" >> $GITHUB_OUTPUT
          echo "Updated version to $NEW_VERSION (updated=$UPDATED)"

      - name: Update changelog
        if: steps.update.outputs.updated == 'true'
        env:
          NEW_VERSION: ${{ needs.determine-bump.outputs.new_version }}
          PREVIOUS_TAG: ${{ needs.determine-bump.outputs.previous_tag }}
        run: |
          python - <<'PY'
          import textwrap

          code = '''
            import datetime
            import os
            import re
            import subprocess
            from pathlib import Path

            new_version = os.environ["NEW_VERSION"]
            previous_tag = os.environ.get("PREVIOUS_TAG", "")
            header = "# Changelog\n\n"

            if previous_tag:
                rev_range = f"{previous_tag}..HEAD"
            else:
                rev_range = ""
            args = ["git", "log"]
            if rev_range:
                args.append(rev_range)
            args.extend(["--pretty=format:%s"])
            result = subprocess.run(args, check=True, capture_output=True, text=True)
            messages = [line.strip() for line in result.stdout.splitlines() if line.strip()]
            if not messages:
                messages = ["chore: maintenance"]

            categories = {"Added": [], "Fixed": [], "Changed": []}
            pattern = re.compile(r"^(?P<type>\w+)(?:\([^)]*\))?!?:\s*")

            for message in messages:
                clean = pattern.sub("", message)
                lower = message.lower()
                if lower.startswith("feat"):
                    categories["Added"].append(clean)
                elif lower.startswith("fix"):
                    categories["Fixed"].append(clean)
                else:
                    categories["Changed"].append(clean)

            entry_lines = [f"## v{new_version} - {datetime.date.today().isoformat()}\n"]
            for section in ("Added", "Fixed", "Changed"):
                items = categories[section]
                if not items:
                    continue
                entry_lines.append(f"### {section}")
                entry_lines.extend(f"- {item}" for item in items)
                entry_lines.append("")
            if len(entry_lines) == 1:
                entry_lines.append("- Maintenance updates")
            entry_lines.append("")
            entry = "\n".join(entry_lines)

            path = Path("CHANGELOG.md")
            if path.exists():
                text = path.read_text()
                if text.startswith(header):
                    body = text[len(header):].lstrip("\n")
                else:
                    body = text
                new_text = header + entry + body
            else:
                new_text = header + entry
            path.write_text(new_text)
          '''
          exec(textwrap.dedent(code))
          PY


      - name: Configure git
        if: steps.update.outputs.updated == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push branch
        if: steps.update.outputs.updated == 'true'
        id: push
        env:
          NEW_VERSION: ${{ needs.determine-bump.outputs.new_version }}
        run: |
          set -euo pipefail
          BRANCH="version-bump/v${NEW_VERSION}"
          git fetch origin main --depth=1
          git checkout -B "$BRANCH" origin/main
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          git commit -m "chore: bump version to v${NEW_VERSION}"
          git push --force-with-lease origin "$BRANCH"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Create or update PR
        if: steps.push.outputs.branch != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ needs.determine-bump.outputs.new_version }}
          CURRENT_VERSION: ${{ needs.determine-bump.outputs.current_version }}
          BUMP_TYPE: ${{ needs.determine-bump.outputs.bump_type }}
        run: |
          set -euo pipefail
          BRANCH="${{ steps.push.outputs.branch }}"
          TITLE="chore: bump version to v${NEW_VERSION}"
          BODY_FILE="pr-body.md"
          printf '## Summary\n- bump version from v%s to v%s\n- bump type: %s\n- generated automatically by Version Bump workflow\n' "$CURRENT_VERSION" "$NEW_VERSION" "$BUMP_TYPE" > "$BODY_FILE"
          EXISTING_PR=$(gh pr list --head "$BRANCH" --state open --json number --jq '.[0].number // ""')
          if [ -z "$EXISTING_PR" ]; then
            gh pr create --base main --head "$BRANCH" --title "$TITLE" --body-file "$BODY_FILE"
          else
            echo "PR #$EXISTING_PR already open for $BRANCH"
          fi

      - name: Output PR details
        if: steps.push.outputs.branch != ''
        run: |
          NEW_VERSION="${{ needs.determine-bump.outputs.new_version }}"
          CURRENT_VERSION="${{ needs.determine-bump.outputs.current_version }}"
          BUMP_TYPE="${{ needs.determine-bump.outputs.bump_type }}"
          BRANCH="${{ steps.push.outputs.branch }}"

          echo "## Version Bump" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Current | New | Type |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|------|" >> $GITHUB_STEP_SUMMARY
          echo "| v${CURRENT_VERSION} | v${NEW_VERSION} | ${BUMP_TYPE} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Branch \`${BRANCH}\` has been pushed. PR was created/updated automatically." >> $GITHUB_STEP_SUMMARY

      - name: No updates needed
        if: steps.update.outputs.updated != 'true'
        run: |
          echo "## No Version Files Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No version files found to update. Consider creating one of:" >> $GITHUB_STEP_SUMMARY
          echo "- VERSION file" >> $GITHUB_STEP_SUMMARY
          echo "- pyproject.toml with version field" >> $GITHUB_STEP_SUMMARY
          echo "- src/__init__.py with __version__" >> $GITHUB_STEP_SUMMARY
