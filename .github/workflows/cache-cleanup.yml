name: Cache Cleanup

on:
  pull_request:
    types: [closed]
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday midnight
  workflow_dispatch:
    inputs:
      cleanup_type:
        description: 'Type of cleanup'
        required: true
        type: choice
        options:
          - pr-caches
          - stale-caches
          - all-caches
      dry_run:
        description: 'Dry run (show what would be deleted)'
        required: false
        type: boolean
        default: true

permissions:
  actions: write
  contents: read

jobs:
  cleanup-pr-cache:
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && inputs.cleanup_type == 'pr-caches')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Cleanup PR caches
        uses: actions/github-script@v8
        with:
          script: |
            const ref = context.payload.pull_request?.head.ref || '';
            const dryRun = context.eventName === 'workflow_dispatch' ? ${{ inputs.dry_run || false }} : false;

            if (!ref && context.eventName === 'pull_request') {
              console.log('No PR ref found, skipping cleanup');
              return;
            }

            console.log(`Cleaning up caches for ref: ${ref}`);
            console.log(`Dry run: ${dryRun}`);

            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: ref ? `refs/heads/${ref}` : undefined,
                per_page: 100
              }
            );

            console.log(`Found ${caches.length} caches`);

            let deleted = 0;
            let totalSize = 0;

            for (const cache of caches) {
              totalSize += cache.size_in_bytes || 0;

              if (dryRun) {
                console.log(`Would delete: ${cache.key} (${(cache.size_in_bytes / 1024 / 1024).toFixed(2)} MB)`);
              } else {
                try {
                  await github.rest.actions.deleteActionsCacheById({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    cache_id: cache.id
                  });
                  deleted++;
                  console.log(`Deleted: ${cache.key}`);
                } catch (e) {
                  console.log(`Failed to delete ${cache.key}: ${e.message}`);
                }
              }
            }

            console.log(`\nSummary:`);
            console.log(`- Total caches: ${caches.length}`);
            console.log(`- Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
            console.log(`- Deleted: ${deleted}`);

  cleanup-stale-caches:
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && (inputs.cleanup_type == 'stale-caches' || inputs.cleanup_type == 'all-caches'))
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Cleanup stale caches
        uses: actions/github-script@v8
        with:
          script: |
            const dryRun = context.eventName === 'workflow_dispatch' ? ${{ inputs.dry_run || false }} : false;
            const maxAgeDays = 7;
            const maxAgeMs = maxAgeDays * 24 * 60 * 60 * 1000;
            const now = Date.now();

            console.log(`Cleaning up caches older than ${maxAgeDays} days`);
            console.log(`Dry run: ${dryRun}`);

            // Get all branches
            const branches = await github.paginate(
              github.rest.repos.listBranches,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            const activeBranches = new Set(branches.map(b => b.name));
            console.log(`Active branches: ${activeBranches.size}`);

            // Get all caches
            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            console.log(`Total caches: ${caches.length}`);

            let deleted = 0;
            let deletedSize = 0;
            const summary = {
              stale: [],
              orphaned: [],
              kept: []
            };

            for (const cache of caches) {
              const age = now - new Date(cache.last_accessed_at).getTime();
              const isStale = age > maxAgeMs;

              // Extract branch from ref (refs/heads/branch-name)
              const branchMatch = cache.ref?.match(/refs\/heads\/(.+)/);
              const branch = branchMatch ? branchMatch[1] : null;
              const isOrphaned = branch && !activeBranches.has(branch);

              const shouldDelete = isStale || isOrphaned;

              if (shouldDelete) {
                const reason = isOrphaned ? 'orphaned' : 'stale';
                const sizeInMB = (cache.size_in_bytes / 1024 / 1024).toFixed(2);

                if (dryRun) {
                  console.log(`Would delete (${reason}): ${cache.key} - ${sizeInMB} MB`);
                  summary[reason === 'orphaned' ? 'orphaned' : 'stale'].push(cache.key);
                } else {
                  try {
                    await github.rest.actions.deleteActionsCacheById({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      cache_id: cache.id
                    });
                    deleted++;
                    deletedSize += cache.size_in_bytes || 0;
                    console.log(`Deleted (${reason}): ${cache.key}`);
                    summary[reason === 'orphaned' ? 'orphaned' : 'stale'].push(cache.key);
                  } catch (e) {
                    console.log(`Failed to delete ${cache.key}: ${e.message}`);
                  }
                }
              } else {
                summary.kept.push(cache.key);
              }
            }

            console.log(`\n## Summary`);
            console.log(`- Total caches: ${caches.length}`);
            console.log(`- Stale caches: ${summary.stale.length}`);
            console.log(`- Orphaned caches: ${summary.orphaned.length}`);
            console.log(`- Kept: ${summary.kept.length}`);
            console.log(`- Deleted: ${deleted}`);
            console.log(`- Space freed: ${(deletedSize / 1024 / 1024).toFixed(2)} MB`);

  report-cache-usage:
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Generate cache report
        uses: actions/github-script@v8
        with:
          script: |
            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            // Group by prefix
            const byPrefix = {};
            let totalSize = 0;

            for (const cache of caches) {
              const prefix = cache.key.split('-')[0];
              if (!byPrefix[prefix]) {
                byPrefix[prefix] = { count: 0, size: 0 };
              }
              byPrefix[prefix].count++;
              byPrefix[prefix].size += cache.size_in_bytes || 0;
              totalSize += cache.size_in_bytes || 0;
            }

            let report = `## ðŸ“Š Cache Usage Report\n\n`;
            report += `**Total caches:** ${caches.length}\n`;
            report += `**Total size:** ${(totalSize / 1024 / 1024 / 1024).toFixed(2)} GB\n\n`;
            report += `### By Type\n\n`;
            report += `| Type | Count | Size |\n`;
            report += `|------|-------|------|\n`;

            for (const [prefix, data] of Object.entries(byPrefix).sort((a, b) => b[1].size - a[1].size)) {
              report += `| ${prefix} | ${data.count} | ${(data.size / 1024 / 1024).toFixed(2)} MB |\n`;
            }

            console.log(report);

            // Write to summary
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, report);
