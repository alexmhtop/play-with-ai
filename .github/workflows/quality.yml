name: Quality and Safety

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  UV_VERSION: "0.4.21"

permissions:
  contents: read
  pull-requests: read

jobs:
  changes:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      python: ${{ steps.filter.outputs.python }}
      docker: ${{ steps.filter.outputs.docker }}
      terraform: ${{ steps.filter.outputs.terraform }}
      ci: ${{ steps.filter.outputs.ci }}
    steps:
      - uses: actions/checkout@v6
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            python:
              - 'src/**'
              - 'tests/**'
              - 'requirements*.txt'
              - 'pyproject.toml'
              - 'setup.py'
              - 'setup.cfg'
            docker:
              - 'Dockerfile'
              - 'docker-compose*.yml'
              - '.dockerignore'
            terraform:
              - 'infra/terraform/**'
            ci:
              - '.github/workflows/**'

  lint_and_unit:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: changes
    if: needs.changes.outputs.python == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    env:
      APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      POSTGRES_HOST: 127.0.0.1
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
      PYTHONPATH: ${{ github.workspace }}
    services:
      postgres:
        image: postgres:16-alpine
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
          --health-start-period=20s
    steps:
      - uses: actions/checkout@v6
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Set up uv
        uses: astral-sh/setup-uv@v5
        with:
          version: ${{ env.UV_VERSION }}
          enable-cache: true
      - name: Cache virtualenv
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.UV_VERSION }}-${{ hashFiles('requirements.txt', 'pyproject.toml') }}
          restore-keys: |
            venv-${{ runner.os }}-${{ env.UV_VERSION }}-
      - name: Cache APT packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: postgresql-client
          version: 1.0
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              exit 0
            fi
            echo "postgres:5432 - no response"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker ps -a
          docker logs $(docker ps -aq --filter "name=postgres")
          exit 1
      - name: Lint
        run: make lint
      - name: Unit tests with coverage
        run: make unit PYTEST_ARGS="--cov=src --cov-report=xml --cov-report=term-missing --cov-fail-under=70"
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: coverage.xml
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.xml
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  security_scans:
    runs-on: ubuntu-latest
    timeout-minutes: 8
    needs: [changes, lint_and_unit]
    if: |
      (needs.changes.outputs.python == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch') &&
      (needs.lint_and_unit.result == 'success' || needs.lint_and_unit.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        target: ["audit", "security-scan"]
    steps:
      - uses: actions/checkout@v6
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Set up uv
        uses: astral-sh/setup-uv@v5
        with:
          version: ${{ env.UV_VERSION }}
          enable-cache: true
      - name: Cache virtualenv
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.UV_VERSION }}-${{ hashFiles('requirements.txt', 'pyproject.toml') }}
          restore-keys: |
            venv-${{ runner.os }}-${{ env.UV_VERSION }}-
      - name: Run ${{ matrix.target }}
        run: make ${{ matrix.target }}

  integration_and_smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [changes, lint_and_unit, security_scans]
    if: |
      always() &&
      (needs.lint_and_unit.result == 'success' || needs.lint_and_unit.result == 'skipped') &&
      (needs.security_scans.result == 'success' || needs.security_scans.result == 'skipped') &&
      (needs.changes.outputs.python == 'true' || needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - uses: actions/checkout@v6
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Set up uv
        uses: astral-sh/setup-uv@v5
        with:
          version: ${{ env.UV_VERSION }}
          enable-cache: true
      - name: Prepare env
        run: |
          if [ -f .env.example ]; then
            cp .env.example .env
          else
            printf '%s\n' \
              "POSTGRES_USER=postgres" \
              "POSTGRES_PASSWORD=postgres" \
              "POSTGRES_DB=postgres" \
              "POSTGRES_HOST=db" \
              "POSTGRES_PORT=5432" \
              "" \
              "KEYCLOAK_ADMIN=admin" \
              "KEYCLOAK_ADMIN_PASSWORD=admin-pass" \
              "KEYCLOAK_HOSTNAME=localhost" \
              "" \
              "APP_DATABASE_URL=postgresql+psycopg://postgres:postgres@db:5432/postgres" \
              "APP_KEYCLOAK_ISSUER=https://localhost/realms/books" \
              "APP_JWKS_URL=http://keycloak:8080/realms/books/protocol/openid-connect/certs" \
              "APP_REQUIRE_HTTPS=false" \
              "APP_STRICT_SECURITY=false" \
              "" \
              "OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4318" \
              "OTEL_SERVICE_NAME=books-api" \
              "APP_CORS_ORIGINS=" \
              "PYROSCOPE_SERVER_ADDRESS=http://pyroscope:4040" \
              "PYROSCOPE_APP_NAME=books-api" \
              "" \
              "GRAFANA_ADMIN_USER=admin" \
              "GRAFANA_ADMIN_PASSWORD=admin" \
              "" \
              "VAULT_DEV_ROOT_TOKEN_ID=root" \
              "VAULT_ADDR=http://vault:8200" \
              > .env
          fi
      - name: Start core services for integration
        run: docker compose up -d db keycloak tempo otel-collector loki victoria-metrics pyroscope
      - name: Cache APT packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: postgresql-client
          version: 1.0
      - name: Install test deps
        env:
          UV_NO_SYNC: "1"
        run: |
          uv pip install --system -r requirements.txt
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              echo "Postgres is ready"
              exit 0
            fi
            echo "postgres:5432 - still waiting (${i})"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker compose ps || true
          docker compose logs db || true
          exit 1
      - name: Wait for Keycloak
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/master/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Keycloak is ready"
              exit 0
            fi
            # Check if container is still running
            if ! docker compose ps keycloak | grep -q "Up"; then
              echo "Keycloak container is not running!" >&2
              docker compose ps || true
              docker compose logs keycloak --tail=50 || true
              exit 1
            fi
            echo "Keycloak - waiting (${i}/30)"
            docker compose logs keycloak --tail=3 2>/dev/null | tail -1 || true
            sleep 5
          done
          echo "Keycloak did not become ready after 150s" >&2
          docker compose ps || true
          docker compose logs keycloak --tail=100 || true
          exit 1
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: infra/terraform/keycloak/.terraform/providers
          key: terraform-keycloak-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-keycloak-
      - name: Create Keycloak realm via Terraform
        run: |
          cd infra/terraform/keycloak
          terraform init
          terraform apply -auto-approve \
            -var="kc_url=http://localhost:8080" \
            -var="kc_admin_client_id=admin-cli" \
            -var="kc_admin_username=admin" \
            -var="kc_admin_password=admin-pass" \
            -var="client_id=books-api" \
            -var="client_secret=ci-test-secret" \
            -var='redirect_uris=["http://localhost:8000/callback"]'
      - name: Wait for books realm
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/books/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Books realm is ready"
              exit 0
            fi
            echo "Books realm - still waiting (${i})"
            sleep 2
          done
          echo "Books realm did not become ready" >&2
          exit 1
      - name: Install test deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Integration tests
        run: pytest -m integration
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      - name: Observability smoke (emit trace and verify Tempo)
        run: |
          python - <<'PY'
          import time, json, sys
          from opentelemetry import trace
          from opentelemetry.sdk.resources import Resource
          from opentelemetry.sdk.trace import TracerProvider
          from opentelemetry.sdk.trace.export import BatchSpanProcessor
          from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
          from opentelemetry.trace import format_trace_id

          provider = TracerProvider(resource=Resource.create({"service.name": "ci-smoke"}))
          provider.add_span_processor(BatchSpanProcessor(OTLPSpanExporter(endpoint="http://localhost:4318/v1/traces")))
          trace.set_tracer_provider(provider)
          tracer = trace.get_tracer(__name__)
          with tracer.start_as_current_span("ci-span") as span:
              tid = format_trace_id(span.get_span_context().trace_id)
          provider.shutdown()
          time.sleep(5)
          import urllib.request
          resp = urllib.request.urlopen(f"http://localhost:3200/api/traces/{tid}")
          data = resp.read()
          parsed = json.loads(data)
          if "batches" not in parsed:
              sys.exit("Tempo trace fetch failed")
          print("tempo trace ok", tid)
          PY
      - name: Loki log smoke
        run: |
          python - <<'PY'
          import json, time, urllib.request

          ts = int(time.time() * 1_000_000_000)
          payload = {
              "streams": [
                  {
                      "stream": {"app": "ci-smoke"},
                      "values": [[str(ts), "ci smoke log line"]],
                  }
              ]
          }
          req = urllib.request.Request(
              "http://localhost:3100/loki/api/v1/push",
              data=json.dumps(payload).encode(),
              headers={"Content-Type": "application/json"},
          )
          urllib.request.urlopen(req).read()
          time.sleep(2)
          query = urllib.request.urlopen(
              "http://localhost:3100/loki/api/v1/query?query={app=\"ci-smoke\"}&limit=1"
          ).read()
          data = json.loads(query)
          if not data.get("data", {}).get("result"):
              raise SystemExit("Loki query returned no results")
          print("loki log ok")
          PY

  docker_build_and_scan:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [changes, lint_and_unit, security_scans]
    if: |
      always() &&
      (needs.lint_and_unit.result == 'success' || needs.lint_and_unit.result == 'skipped') &&
      (needs.security_scans.result == 'success' || needs.security_scans.result == 'skipped') &&
      (needs.changes.outputs.python == 'true' || needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch')
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository }}
    steps:
      - uses: actions/checkout@v6
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          load: true
          tags: local/build:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Trivy image scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: local/build:latest
          severity: CRITICAL,HIGH
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: local/build:latest
          artifact-name: sbom.spdx.json
          output-file: sbom.spdx.json
      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 30

  terraform_check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: changes
    if: needs.changes.outputs.terraform == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v6
      - uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: |
            infra/terraform/keycloak/.terraform/providers
            infra/terraform/vault/.terraform/providers
          key: terraform-shared-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl', 'infra/terraform/vault/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-shared-
      - name: Terraform fmt/validate
        run: |
          terraform fmt -check -recursive infra
          (cd infra/terraform/keycloak && terraform init -backend=false && terraform validate)
          (cd infra/terraform/vault && terraform init -backend=false && terraform validate)
      - name: tfsec security scan
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: infra/terraform
          soft_fail: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  vault_seed_smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [changes, terraform_check]
    if: needs.changes.outputs.terraform == 'true' || github.event_name == 'workflow_dispatch'
    env:
      VAULT_ADDR: http://127.0.0.1:8200
      VAULT_DEV_ROOT_TOKEN_ID: root
      VAULT_TEST_SECRET: ci-test-secret
    steps:
      - uses: actions/checkout@v6
      - name: Start Vault dev server
        run: |
          docker run -d --name vault-ci -p 8200:8200 -e VAULT_DEV_ROOT_TOKEN_ID=${VAULT_DEV_ROOT_TOKEN_ID} hashicorp/vault:1.17.6
      - name: Wait for Vault
        run: |
          for i in {1..30}; do
            if curl -sf ${VAULT_ADDR}/v1/sys/health >/dev/null 2>&1; then
              exit 0
            fi
            echo "vault still starting (${i}/30)"
            sleep 2
          done
          docker logs vault-ci || true
          exit 1
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers (vault)
        uses: actions/cache@v4
        with:
          path: infra/terraform/vault/.terraform/providers
          key: terraform-vault-${{ hashFiles('infra/terraform/vault/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-vault-
      - name: Apply vault seed
        run: |
          cd infra/terraform/vault
          terraform init
          terraform apply -auto-approve \
            -var="vault_addr=${VAULT_ADDR}" \
            -var="vault_token=${VAULT_DEV_ROOT_TOKEN_ID}" \
            -var="database_url=postgresql+psycopg://postgres:postgres@db:5432/postgres" \
            -var="books_api_client_secret=${VAULT_TEST_SECRET}"
      - name: Verify Vault secret exists
        run: |
          python - <<'PY'
          import json, os, urllib.request

          addr = os.environ['VAULT_ADDR'] + '/v1/kv/data/books-api/config'
          token = os.environ['VAULT_DEV_ROOT_TOKEN_ID']
          req = urllib.request.Request(addr, headers={'X-Vault-Token': token})
          data = json.load(urllib.request.urlopen(req))
          payload = data['data']['data']
          if not payload.get('database_url') or payload.get('client_secret') != os.environ['VAULT_TEST_SECRET']:
              raise SystemExit('Vault secret payload mismatch')
          PY
      - name: Cleanup Vault
        if: always()
        run: docker rm -f vault-ci

  hadolint:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: changes
    if: needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v6
      - name: Hadolint Dockerfile
        uses: hadolint/hadolint-action@v3.3.0
        with:
          dockerfile: Dockerfile

  dependency_review:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v6
      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
          deny-licenses: GPL-3.0, AGPL-3.0

  pr_title:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'pull_request'
    steps:
      - name: Validate PR title (Conventional Commits)
        uses: amannn/action-semantic-pull-request@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
            revert
          requireScope: false
          subjectPattern: ^.{1,80}$
          subjectPatternError: |
            PR title must be 1-80 characters.

  # gitleaks:
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 5
  #   steps:
  #     - uses: actions/checkout@v6
  #       with:
  #         fetch-depth: 0
  #     - name: Gitleaks scan
  #       uses: gitleaks/gitleaks-action@v2
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
