name: Quality and Safety

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  lint_and_test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      POSTGRES_HOST: 127.0.0.1
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    services:
      postgres:
        image: postgres:16-alpine
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
          --health-start-period=20s
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Install Postgres client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pip-audit bandit
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              exit 0
            fi
            echo "postgres:5432 - no response"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker ps -a
          docker logs $(docker ps -aq --filter "name=postgres")
          exit 1
      - name: Unit tests (no integration)
        run: pytest -m "not integration"
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      - name: Security lint (bandit)
        run: bandit -q -r src
      - name: pip-audit
        run: pip-audit -r requirements.txt

  integration_and_smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: lint_and_test
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Prepare env
        run: |
          if [ -f .env.example ]; then
            cp .env.example .env
          else
            printf '%s\n' \
              "POSTGRES_USER=postgres" \
              "POSTGRES_PASSWORD=postgres" \
              "POSTGRES_DB=postgres" \
              "POSTGRES_HOST=db" \
              "POSTGRES_PORT=5432" \
              "" \
              "KEYCLOAK_ADMIN=admin" \
              "KEYCLOAK_ADMIN_PASSWORD=admin-pass" \
              "KEYCLOAK_HOSTNAME=localhost" \
              "" \
              "APP_DATABASE_URL=postgresql+psycopg://postgres:postgres@db:5432/postgres" \
              "APP_KEYCLOAK_ISSUER=https://localhost/realms/books" \
              "APP_JWKS_URL=http://keycloak:8080/realms/books/protocol/openid-connect/certs" \
              "APP_REQUIRE_HTTPS=false" \
              "APP_STRICT_SECURITY=false" \
              "" \
              "OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4318" \
              "OTEL_SERVICE_NAME=books-api" \
              "APP_CORS_ORIGINS=" \
              "PYROSCOPE_SERVER_ADDRESS=http://pyroscope:4040" \
              "PYROSCOPE_APP_NAME=books-api" \
              "" \
              "GRAFANA_ADMIN_USER=admin" \
              "GRAFANA_ADMIN_PASSWORD=admin" \
              "" \
              "VAULT_DEV_ROOT_TOKEN_ID=root" \
              "VAULT_ADDR=http://vault:8200" \
              > .env
          fi
      - name: Start core services for integration
        run: docker compose up -d db keycloak tempo otel-collector loki victoria-metrics pyroscope
      - name: Install Postgres client (integration)
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              echo "Postgres is ready"
              exit 0
            fi
            echo "postgres:5432 - still waiting (${i})"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker compose ps || true
          docker compose logs db || true
          exit 1
      - name: Wait for Keycloak
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/master/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Keycloak is ready"
              exit 0
            fi
            # Check if container is still running
            if ! docker compose ps keycloak | grep -q "Up"; then
              echo "Keycloak container is not running!" >&2
              docker compose ps || true
              docker compose logs keycloak --tail=50 || true
              exit 1
            fi
            echo "Keycloak - waiting (${i}/30)"
            docker compose logs keycloak --tail=3 2>/dev/null | tail -1 || true
            sleep 5
          done
          echo "Keycloak did not become ready after 150s" >&2
          docker compose ps || true
          docker compose logs keycloak --tail=100 || true
          exit 1
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: infra/terraform/keycloak/.terraform/providers
          key: terraform-keycloak-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-keycloak-
      - name: Create Keycloak realm via Terraform
        run: |
          cd infra/terraform/keycloak
          terraform init
          terraform apply -auto-approve \
            -var="kc_url=http://localhost:8080" \
            -var="kc_admin_client_id=admin-cli" \
            -var="kc_admin_username=admin" \
            -var="kc_admin_password=admin-pass" \
            -var="client_id=books-api" \
            -var="client_secret=ci-test-secret" \
            -var='redirect_uris=["http://localhost:8000/callback"]'
      - name: Wait for books realm
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/books/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Books realm is ready"
              exit 0
            fi
            echo "Books realm - still waiting (${i})"
            sleep 2
          done
          echo "Books realm did not become ready" >&2
          exit 1
      - name: Install test deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Integration tests
        run: pytest -m integration
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      - name: Observability smoke (emit trace and verify Tempo)
        run: |
          python - <<'PY'
          import time, json, sys
          from opentelemetry import trace
          from opentelemetry.sdk.resources import Resource
          from opentelemetry.sdk.trace import TracerProvider
          from opentelemetry.sdk.trace.export import BatchSpanProcessor
          from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
          from opentelemetry.trace import format_trace_id

          provider = TracerProvider(resource=Resource.create({"service.name": "ci-smoke"}))
          provider.add_span_processor(BatchSpanProcessor(OTLPSpanExporter(endpoint="http://localhost:4318/v1/traces")))
          trace.set_tracer_provider(provider)
          tracer = trace.get_tracer(__name__)
          with tracer.start_as_current_span("ci-span") as span:
              tid = format_trace_id(span.get_span_context().trace_id)
          provider.shutdown()
          time.sleep(5)
          import urllib.request
          resp = urllib.request.urlopen(f"http://localhost:3200/api/traces/{tid}")
          data = resp.read()
          parsed = json.loads(data)
          if "batches" not in parsed:
              sys.exit("Tempo trace fetch failed")
          print("tempo trace ok", tid)
          PY

  docker_build_and_scan:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: lint_and_test
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          load: true
          tags: local/build:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Trivy image scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: local/build:latest
          severity: CRITICAL,HIGH

  terraform_check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: infra/terraform/keycloak/.terraform/providers
          key: terraform-keycloak-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-keycloak-
      - name: Terraform fmt/validate
        run: |
          terraform fmt -check -recursive infra
          (cd infra/terraform/keycloak && terraform init -backend=false && terraform validate)

  hadolint:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
      - name: Hadolint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile

  # gitleaks:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v4
  #     - name: Gitleaks scan
  #       uses: gitleaks/gitleaks-action@v2
  #       with:
  #         args: detect --source . --no-git --verbose
