name: Quality and Safety

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read

jobs:
  changes:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      python: ${{ steps.filter.outputs.python }}
      docker: ${{ steps.filter.outputs.docker }}
      terraform: ${{ steps.filter.outputs.terraform }}
      ci: ${{ steps.filter.outputs.ci }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            python:
              - 'src/**'
              - 'tests/**'
              - 'requirements*.txt'
              - 'pyproject.toml'
              - 'setup.py'
              - 'setup.cfg'
            docker:
              - 'Dockerfile'
              - 'docker-compose*.yml'
              - '.dockerignore'
            terraform:
              - 'infra/terraform/**'
            ci:
              - '.github/workflows/**'

  lint_and_test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: changes
    if: needs.changes.outputs.python == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    env:
      APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      POSTGRES_HOST: 127.0.0.1
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    services:
      postgres:
        image: postgres:16-alpine
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
          --health-start-period=20s
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Cache APT packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: postgresql-client
          version: 1.0
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pip-audit bandit pytest-cov ruff mypy
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              exit 0
            fi
            echo "postgres:5432 - no response"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker ps -a
          docker logs $(docker ps -aq --filter "name=postgres")
          exit 1
      - name: Unit tests with coverage
        run: pytest -m "not integration" --cov=src --cov-report=xml --cov-report=term-missing --cov-fail-under=70
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      - name: Ruff lint
        run: ruff check src tests
      - name: Ruff format check
        run: ruff format --check src tests
      - name: Type check (mypy)
        run: mypy src --ignore-missing-imports --no-error-summary || true
      - name: Security lint (bandit)
        run: bandit -q -r src
      - name: pip-audit
        run: pip-audit -r requirements.txt

  integration_and_smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [changes, lint_and_test]
    if: |
      always() &&
      (needs.lint_and_test.result == 'success' || needs.lint_and_test.result == 'skipped') &&
      (needs.changes.outputs.python == 'true' || needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Prepare env
        run: |
          if [ -f .env.example ]; then
            cp .env.example .env
          else
            printf '%s\n' \
              "POSTGRES_USER=postgres" \
              "POSTGRES_PASSWORD=postgres" \
              "POSTGRES_DB=postgres" \
              "POSTGRES_HOST=db" \
              "POSTGRES_PORT=5432" \
              "" \
              "KEYCLOAK_ADMIN=admin" \
              "KEYCLOAK_ADMIN_PASSWORD=admin-pass" \
              "KEYCLOAK_HOSTNAME=localhost" \
              "" \
              "APP_DATABASE_URL=postgresql+psycopg://postgres:postgres@db:5432/postgres" \
              "APP_KEYCLOAK_ISSUER=https://localhost/realms/books" \
              "APP_JWKS_URL=http://keycloak:8080/realms/books/protocol/openid-connect/certs" \
              "APP_REQUIRE_HTTPS=false" \
              "APP_STRICT_SECURITY=false" \
              "" \
              "OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4318" \
              "OTEL_SERVICE_NAME=books-api" \
              "APP_CORS_ORIGINS=" \
              "PYROSCOPE_SERVER_ADDRESS=http://pyroscope:4040" \
              "PYROSCOPE_APP_NAME=books-api" \
              "" \
              "GRAFANA_ADMIN_USER=admin" \
              "GRAFANA_ADMIN_PASSWORD=admin" \
              "" \
              "VAULT_DEV_ROOT_TOKEN_ID=root" \
              "VAULT_ADDR=http://vault:8200" \
              > .env
          fi
      - name: Start core services for integration
        run: docker compose up -d db keycloak tempo otel-collector loki victoria-metrics pyroscope
      - name: Cache APT packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: postgresql-client
          version: 1.0
      - name: Wait for Postgres
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U postgres; then
              echo "Postgres is ready"
              exit 0
            fi
            echo "postgres:5432 - still waiting (${i})"
            sleep 2
          done
          echo "Postgres did not become ready" >&2
          docker compose ps || true
          docker compose logs db || true
          exit 1
      - name: Wait for Keycloak
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/master/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Keycloak is ready"
              exit 0
            fi
            # Check if container is still running
            if ! docker compose ps keycloak | grep -q "Up"; then
              echo "Keycloak container is not running!" >&2
              docker compose ps || true
              docker compose logs keycloak --tail=50 || true
              exit 1
            fi
            echo "Keycloak - waiting (${i}/30)"
            docker compose logs keycloak --tail=3 2>/dev/null | tail -1 || true
            sleep 5
          done
          echo "Keycloak did not become ready after 150s" >&2
          docker compose ps || true
          docker compose logs keycloak --tail=100 || true
          exit 1
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: infra/terraform/keycloak/.terraform/providers
          key: terraform-keycloak-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-keycloak-
      - name: Create Keycloak realm via Terraform
        run: |
          cd infra/terraform/keycloak
          terraform init
          terraform apply -auto-approve \
            -var="kc_url=http://localhost:8080" \
            -var="kc_admin_client_id=admin-cli" \
            -var="kc_admin_username=admin" \
            -var="kc_admin_password=admin-pass" \
            -var="client_id=books-api" \
            -var="client_secret=ci-test-secret" \
            -var='redirect_uris=["http://localhost:8000/callback"]'
      - name: Wait for books realm
        run: |
          for i in {1..30}; do
            if curl -sf http://localhost:8080/realms/books/.well-known/openid-configuration >/dev/null 2>&1; then
              echo "Books realm is ready"
              exit 0
            fi
            echo "Books realm - still waiting (${i})"
            sleep 2
          done
          echo "Books realm did not become ready" >&2
          exit 1
      - name: Install test deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Integration tests
        run: pytest -m integration
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_DATABASE_URL: postgresql+psycopg://postgres:postgres@127.0.0.1:5432/postgres
      - name: Observability smoke (emit trace and verify Tempo)
        run: |
          python - <<'PY'
          import time, json, sys
          from opentelemetry import trace
          from opentelemetry.sdk.resources import Resource
          from opentelemetry.sdk.trace import TracerProvider
          from opentelemetry.sdk.trace.export import BatchSpanProcessor
          from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
          from opentelemetry.trace import format_trace_id

          provider = TracerProvider(resource=Resource.create({"service.name": "ci-smoke"}))
          provider.add_span_processor(BatchSpanProcessor(OTLPSpanExporter(endpoint="http://localhost:4318/v1/traces")))
          trace.set_tracer_provider(provider)
          tracer = trace.get_tracer(__name__)
          with tracer.start_as_current_span("ci-span") as span:
              tid = format_trace_id(span.get_span_context().trace_id)
          provider.shutdown()
          time.sleep(5)
          import urllib.request
          resp = urllib.request.urlopen(f"http://localhost:3200/api/traces/{tid}")
          data = resp.read()
          parsed = json.loads(data)
          if "batches" not in parsed:
              sys.exit("Tempo trace fetch failed")
          print("tempo trace ok", tid)
          PY

  docker_build_and_scan:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [changes, lint_and_test]
    if: |
      always() &&
      (needs.lint_and_test.result == 'success' || needs.lint_and_test.result == 'skipped') &&
      (needs.changes.outputs.python == 'true' || needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch')
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          load: true
          tags: local/build:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Trivy image scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: local/build:latest
          severity: CRITICAL,HIGH
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: local/build:latest
          artifact-name: sbom.spdx.json
          output-file: sbom.spdx.json
      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 30

  terraform_check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: changes
    if: needs.changes.outputs.terraform == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: infra/terraform/keycloak/.terraform/providers
          key: terraform-keycloak-${{ hashFiles('infra/terraform/keycloak/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-keycloak-
      - name: Terraform fmt/validate
        run: |
          terraform fmt -check -recursive infra
          (cd infra/terraform/keycloak && terraform init -backend=false && terraform validate)
      - name: tfsec security scan
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: infra/terraform
          soft_fail: true

  hadolint:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: changes
    if: needs.changes.outputs.docker == 'true' || needs.changes.outputs.ci == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4
      - name: Hadolint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile

  dependency_review:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
          deny-licenses: GPL-3.0, AGPL-3.0

  pr_title:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'pull_request'
    steps:
      - name: Validate PR title (Conventional Commits)
        uses: amannn/action-semantic-pull-request@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
            revert
          requireScope: false
          subjectPattern: ^.{1,80}$
          subjectPatternError: |
            PR title must be 1-80 characters.

  # gitleaks:
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 5
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0
  #     - name: Gitleaks scan
  #       uses: gitleaks/gitleaks-action@v2
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
